// parser boilerplate code
namespace details {

    template<
            class _t,
            class _class_t,
            bool (_class_t::*_val_method)() const,
            _t (_class_t::*_get_method)() const
    >
    inline bool read(const _class_t &parser, _t &dest) {
        if (!(parser.*_val_method)())
            return false;
        dest = (parser.*_get_method)();
        return true;
    }

    inline bool read(const value & parser, string & dest) {
        if (!parser.is_string ())
            return false;
        dest = parser.as_string();
        return true;
    }
}


inline bool read (const value & parser, bool & dest ) {
    return details::read <
            bool,
            value,
            &value::is_boolean,
            &value::as_bool
    > ( parser, dest);
}

inline bool read (const value & parser, string & dest ) {
    return details::read (parser, dest);
}

inline bool read (const value & parser, int32_t & dest ) {
    if (!parser.is_number ())
        return false;

    return details::read <
            int32_t,
            number,
            &number::is_int32,
            &number::to_int32
    >( parser.as_number (), dest );
}

inline bool read (const value & parser, int64_t & dest ) {
    if (!parser.is_number ())
        return false;

    return details::read <
            int64_t,
            number,
            &number::is_int64,
            &number::to_int64
    >( parser.as_number (), dest );
}

inline bool read (const value & parser, uint32_t & dest ) {
    if (!parser.is_number ())
        return false;

    return details::read <
            uint32_t,
            number,
            &number::is_uint32,
            &number::to_uint32
    >( parser.as_number (), dest );
}

inline bool read (const value & parser, uint64_t & dest ) {
    if (!parser.is_number ())
        return false;

    return details::read <
            uint64_t,
            number,
            &number::is_uint64,
            &number::to_uint64
    >( parser.as_number (), dest );
}

template < class _t >
inline bool read (const value & parser, vector < _t > & dest) {
    if (!parser.is_array())
        return false;

    auto array_obj = parser.as_array ();
    uint64_t size = static_cast < uint64_t > (array_obj.size ());

    dest.resize (size);

    bool success = true;

    for (uint64_t i = 0; i < size; ++i)
        success = read (array_obj.at(i), dest[i]) && success;

    return success;
}

template < class _t > inline bool read_field_details (const object & obj, const char * field_name, _t & dest ) {
    auto it = obj.find (field_name);

    if (it == obj.end ())
        return false;

    return read ((*it).second, dest);
}

// writers
inline value write (const std::string & parser) {
    return web::json::value::string(parser);
}

inline value write (bool parser) {
    return web::json::value::boolean(parser);
}

inline value write (int parser) {
    return web::json::value::number (parser);
}

inline value write (unsigned int parser) {
    return web::json::value::number (parser);
}

inline value write ( double parser ) {
    return web::json::value::number (parser);
}

inline value write_null () {
    return web::json::value::null();
}

template <
        class _t
>
inline value write (const vector < _t > & parser) {

    size_t size = parser.size ();

    if (size == 0)
        return write_null();

    auto array = value::array(size);

    for (size_t i = 0; i < size; ++i)
        array[i] = write (parser[i]);

    return array;
}

// generated code
